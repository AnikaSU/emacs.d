# Created 2019-12-21 Sat 17:14
#+TITLE: A Life Configuring Emacs
#+DATE: 2018-07-25
#+AUTHOR: Musa Al-hassy
#+export_file_name: README.org

#+html: <p align="center"> <img src="emacs-logo.png" width=150 height=150/> </p> <p align="center"> <a href="https://www.gnu.org/software/emacs/"> <img src="https://img.shields.io/badge/GNU%20Emacs-26.1-b48ead.svg?style=plastic"/></a> <a href="https://orgmode.org/"><img src="https://img.shields.io/badge/org--mode-9.3-489a9f.svg?style=plastic"/></a> </p> <p align="center"> <img src="emacs-birthday-present.png" width=200 height=250/> </p>

I enjoy reading others' /literate/ configuration files and
incorporating what I learn into my own. The result is a
sufficiently well-documented and accessible read that yields
a stylish and functional system (•̀ᴗ•́)و

This ~README.org~ has been automatically generated from my
configuration and its contents below are accessible
in (outdated) blog format, with /colour/, or as colourful
PDF, [[https://alhassy.github.io/init/][here]]. Enjoy

#+begin_src emacs-lisp :tangle no :exports results :wrap "export html" :results replace
(concat
"<p align=\"center\">
        <a href=\"https://www.gnu.org/software/emacs/\">
        <img src=\"https://img.shields.io/badge/GNU%20Emacs-" emacs-version "-b48ead.svg?style=plastic\"/></a>
        <a href=\"https://orgmode.org/\"><img src=\"https://img.shields.io/badge/org--mode-" org-version "-489a9f.svg?style=plastic\"/></a>
</p>")
#+end_src

#+begin_center
*Abstract*
#+end_center

Herein I document the configurations I utilise with [[https://gnu.org/s/emacs][Emacs]].

As a [[https://www.offerzen.com/blog/literate-programming-empower-your-writing-with-emacs-org-mode][literate program]] file with [[http://orgmode.org/][Org-mode]], I am ensured optimal navigation
through my ever growing configuration files, ease of usability and reference
for peers, and, most importantly, better maintainability for myself!

Dear reader, when encountering a foregin command ~X~ I encourage you to execute ~(describe-symbol 'X)~, or press ~C-h o~ with the cursor on ~X~.
An elementary Elisp Cheat Sheet can be found [[https://github.com/alhassy/ElispCheatSheet][here]]
and here is a 2-page 3-column [[https://github.com/alhassy/emacs.d/blob/master/CheatSheet.pdf][Emacs Cheat Sheet]] of the bindings
in ~“this”~ configuration.

* Booting Up
Let's decide on where we want to setup our declarations for personalising Emacs
to our needs. Then, let's bootstrap Emacs' primitive packaging mechanism with a
slick interface ---which not only installs Emacs packages but also programs at
the operating system level, all from inside Emacs!  Finally, let's declare who
we are and use that to setup Emacs email service.

** =~/.emacs= vs. =init.org=

/Emacs is extenible/: When Emacs is started, it tried to load a user's Lisp
program known as a initialisation file which specfies how Emacs should look and
behave for you.  Emacs looks for the init file using the filenames =~/.emacs.el,
~/.emacs,= or =~/.emacs.d/init.el= ---it looks for the first one that exists, in
that order; at least it does so on my machine.  Below we'll avoid any confusion
by /ensuring/ that only one of them is in our system.  Regardless, execute =C-h o
user-init-file= to see the name of the init file loaded. Having no init file is
tantamount to have an empty init file.

- One can read about the various Emacs initialisation files [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html#Init-File][online]] or
  within Emacs by the sequence ~C-h i m emacs RET i init file RET~.
- A /friendly/ tutorial on ‘beginning a =.emacs= file’ can be read
  [[https://www.gnu.org/software/emacs/manual/html_node/eintr/Beginning-init-File.html#Beginning-init-File][online]] or within Emacs by ~C-h i m emacs lisp intro RET i .emacs RET~.
- After inserting some lisp code and saving, such as ~(set-background-color
    "salmon")~, one can load the changes with ~M-x eval-buffer~.
- In a terminal, use ~emacs -Q~ to open emacs without any initialisation files.

Besides writing Lisp in an init file, one may use Emacs' customisation
interface, ~M-x customize~: Point and click to change Emacs to your needs. The
resulting customisations are, by default, automatically thrown into your init
file ---=~/.emacs= is created for you if you have no init file.  This interface is
great for beginners, but one major drawback is that it's a bit difficult to
share settings since it's not amicable to copy-pasting.

We shall use =~/.emacs.d/init.el= as the initialisation file so that /all/ of our
Emacs related files live in the /same/ directory: =~/.emacs.d/=.

A raw code file is difficult to maintain, especially for a /large/ system such as
Emacs. Instead, we're going with a ‘literate programming’ approach: The
intialisation configuration is presented in an essay fromat, along with headings
and subheadings, intended for consumption by humans such as myself, that,
incidentally, can be ‘tangled’ into a raw code file that is comprehensible by a
machine. We achieve this goal using [[#Life-within-Org-mode][org-mode]] ---/Emacs' killer app/--- which is
discussed in great detail later on.

*** /Adventure time!/ “Honey, where's my init?”

Let's use the three possible locations for the initialisation files
to explore how Emacs finds them. Make the following three files.

_~/.emacs.el_
#+begin_src emacs-lisp :tangle no
;; Emacs looks for this first;
(set-background-color "chocolate3")
(message-box ".emacs.el says hello")
#+end_src
_~/.emacs_
#+begin_src emacs-lisp :tangle no
;; else; looks for this one;
(set-background-color "plum4")
(message-box ".emacs says hello")
#+end_src
_~/.emacs.d/init.el_
#+begin_src emacs-lisp :tangle no
;; Finally, if neither are found; it looks for this one.
(set-background-color "salmon")
(message-box ".emacs.d/init.el says hello")
#+end_src

Now restart your Emacs to see how there super tiny initilaisation files
affect your editor. Delete some of these files in-order for others to take effect!

*** /Adventure time!/ Using Emacs' Easy Customisation Interface

We have chosen not to keep configurations in ~~/.emacs~ since
Emacs may explicitly add, or alter, code in it.

Let's see this in action!

Execute the following to see additions to the ~~/.emacs~ have been added by
‘custom’.
1. =M-x customize-variable RET line-number-mode RET=
2. Then press: ~toggle~, ~state~, then ~1~.
3. Now take a look: =C-x C-f ~/.emacs=

*** Support for ‘Custom’

Let the Emacs customisation GUI insert configurations into its own file, not
touching or altering my initialisation file.  For example, I tend to have local
variables to produce ~README.org~'s and other matters, so Emacs' Custom utility
will remember to not prompt me each time for the safety of such local variables.
#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+end_src

Speaking of local variables, let's always ones we've already marked as safe
---see the bottom of the source of this file for an example of local variables.
( At one point, all my files had locals! )
#+begin_src emacs-lisp
(setq enable-local-variables :safe)
#+end_src

** =use-package= ---The start of =init.el=

There are a few ways to install packages ---run ~C-h C-e~ for a short overview.
The easiest, for a beginner, is to use the command ~package-list-packages~ then
find the desired package, press ~i~ to mark it for installation, then install all
marked packages by pressing ~x~.

- /Interactively/:  ~M-x list-packages~ to see all melpa packages that can install
  - Not in alphabetical order, so maybe search with ~C-s~.
  - Press ~Enter~ on a package to see its description.
- Or more quickly, to install, say, the haskell mode: ~M-x package-install RET
    unicode-fonts RET~.

“From rags to riches”: Recently I switched to Mac ---first time trying the OS.
I had to do a few ~package-install~'s and it was annoying.  I'm looking for the
best way to package my Emacs installation ---including my installed packages and
configuration--- so that I can quickly install it anywhere, say if I go to
another machine.  It seems ~use-package~ allows me to configure and auto install
packages.  On a new machine, when I clone my ~.emacs.d~ and start Emacs, on the
first start it should automatically install and compile all of my packages
through ~use-package~ when it detects they're missing.

First we load ~package~, the built-in package manager.  It is by default only
connected to the GNU ELPA (Emacs Lisp Package Archive) repository, so we
extended it with other popular repositories; such as the much larger [[https://melpa.org/#/][MELPA]]
(Milkypostman's ELPA) ---it builds packages [[https://github.com/melpa/melpa][directly from the source-code
reposistories of developers]], rather than having all packages in one repository.
#+begin_src emacs-lisp
;; Make all commands of the “package” module present.
(require 'package)

;; Internet repositories for new packages.
(setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                         ("gnu"       . "http://elpa.gnu.org/packages/")
                         ("melpa"     . "http://melpa.org/packages/")
                         ("melpa-stable" . "http://stable.melpa.org/packages/")))

;; Actually get “package” to work.
(package-initialize)
(package-refresh-contents)
#+end_src

- All installed packages are placed, by default, in =~/.emacs.d/elpa=.
- *Neato:* /If one module requires others to run, they will be installed automatically./

The declarative configuration tool [[https://github.com/jwiegley/use-package/][use-package]] is a
macro/interface that manages other packages and the way they interact.
- It allows us to tersely organise a package's configuration.
  - By default, ~(use-package foo)~ only loads a package, if it's on our system.
    - Use the standalone keyword ~:disabled~ to turn off loading
      a module that, say, you're not using anymore.
- It is /not/ a package manger, but we can make it one by having it automatically
  install modules, via Emacs packing mechanism, when they're not in our system.

  We achieve this by using the keyword option ~:ensure t~.
- Here are common keywords we will use, in super simplified terms.
  - ~:init   f₁ … fₙ~  /Always/ executes code forms ~fᵢ~ /before/ loading a package.
  - ~:diminish str~  Uses /optional/ string ~str~ in the modeline to indicate
    this module is active. Things we use often needn't take
    real-estate down there and so no we provide no ~str~.
  - ~:config f₁ … fₙ~ /Only/ executes code forms ~fᵢ~ /after/ loading a package.

    The remaining keywords only take affect /after/ a module loads.

  - ~:bind ((k₁ . f₁) … (kₙ . fₙ)~ Lets us bind keys ~kᵢ~, such as
    ~"M-s o"~, to functions, such as =occur=.
    - When /n = 1/, the extra outer parenthesis are not necessary.
  - ~:hook ((m₁ … mₙ) . f)~ Enables functionality ~f~ whenever we're in one of the
    modes ~mᵢ~, such as ~org-mode~. The ~. f~, along with the outermost parenthesis,
    is optional and defaults to the name of the package ---Warning: Erroneous
    behaviour happens if the package's name is not a function provided by the
    package; a common case is when package's name does /not/ end in ~-mode~,
    leading to the invocation ~((m₁ … mₙ) . <whatever-the-name-is>-mode)~ instead.

    Additionally, when /n = 1/, the extra outer parenthesis are not necessary.
  - ~:custom (k₁ v₁ d₁) … (kₙ vₙ dₙ)~ Sets a package's custom variables ~kᵢ~ to have
    values ~vᵢ~, along with /optional/ user documentation ~dᵢ~ to explain to yourself,
    in the future, why you've made this decision.

    This is essentially ~setq~ within ~:config~.

We now bootstrap ~use-package~.
#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(require 'use-package)
#+end_src

We can now invoke ~(use-package XYZ :ensure t)~ which should check for the ~XYZ~
package and make sure it is accessible.  If not, the ~:ensure t~ part tells
~use-package~ to download it ---using the built-in ~package~ manager--- and place it
somewhere accessible, in =~/.emacs.d/elpa/= by default.  By default we would like
to download packages, since I do not plan on installing them manually by
downloading Lisp files and placing them in the correct places on my system.
#+begin_src emacs-lisp
(setq use-package-always-ensure t)
#+end_src
The use of ~:ensure t~ only installs absent modules, but it does no updating.
Let's set up [[https://github.com/rranelli/auto-package-update.el][an auto-update mechanism]].
#+begin_src emacs-lisp
(use-package auto-package-update
  :config
  ;; Delete residual old versions
  (setq auto-package-update-delete-old-versions t)
  ;; Do not bother me when updates have taken place.
  (setq auto-package-update-hide-results t)
  ;; Update installed packages at startup if there is an update pending.
  (auto-package-update-maybe))
#+end_src

Here's another example use of ~use-package~.  Later on, I have a “show recent files
pop-up” command set to ~C-x C-r~; but what if I forget? This mode shows me all key
completions when I type ~C-x~, for example.  Moreover, I will be shown other
commands I did not know about! Neato :-)
#+begin_src emacs-lisp
;; Making it easier to discover Emacs key presses.
(use-package which-key
  :diminish
  :config (which-key-mode)
          (which-key-setup-side-window-bottom)
          (setq which-key-idle-delay 0.05))
#+end_src
⟨ Honestly, I seldom even acknowledge this pop-up; but it's always nice to show
to people when I'm promoting Emacs. ⟩

Above, the ~:diminish~ keyword indicates that we do not want the mode's name to be
shown to us in the modeline ---the area near the bottom of Emacs.  It does so by
using the ~diminish~ package, so let's install that.
#+begin_src emacs-lisp
(use-package diminish
  :config ;; Let's hide some markers.
    (diminish 'eldoc-mode)
    (diminish 'org-indent-mode)
    (diminish 'subword-mode))
#+end_src

Here are other packages that I want to be installed onto my machine.
#+begin_src emacs-lisp
;; Efficient version control.
(use-package magit
  :config (global-set-key (kbd "C-x g") 'magit-status))

(use-package htmlize)
;; Main use: Org produced htmls are coloured.
;; Can be used to export a file into a coloured html.

;; Quick BibTeX references, sometimes.
(use-package biblio)

;; Get org-headers to look pretty! E.g., * → ⊙, ** ↦ ◯, *** ↦ ★
;; https://github.com/emacsorphanage/org-bullets
(use-package org-bullets
  :hook (org-mode . org-bullets-mode))

;; Haskell's cool
(use-package haskell-mode)

;; Lisp libraries with Haskell-like naming.
(use-package dash)    ;; “A modern list library for Emacs”
(use-package s   )    ;; “The long lost Emacs string manipulation library”.

;; Library for working with system files;
;; e.g., f-delete, f-mkdir, f-move, f-exists?, f-hidden?
(use-package f)
#+end_src

Note:
- [[https://github.com/magnars/dash.el][dash]]: “A modern list library for Emacs”
  - E.g., ~(--filter (> it 10) (list 8 9 10 11 12))~
- [[https://github.com/magnars/s.el][s]]: “The long lost Emacs string manipulation library”.
  - E.g., ~s-trim, s-replace, s-join~.

** ~README~ ---From ~init.org~ to ~init.el~

Rather than manually extracting the Lisp code from this literate document each
time we alter it, let's instead add a ‘hook’ ---a method that is invoked on a
particular event, in this case when we save the file.  More precisely, in this
case, ~C-x C-s~ is a normal save whereas ~C-u C-x C-s~ is a save after forming
~init.elc~ and ~README.md~.

#+name: enable making init and readme
#+begin_src emacs-lisp :eval never-export
(defun my/make-init-el-and-README ()
    (interactive "P") ;; Places value of universal argument into: current-prefix-arg
    (when current-prefix-arg
      (let* ((time      (current-time))
                 (_date     (format-time-string "_%Y-%m-%d"))
                 (.emacs    "~/.emacs")
                 (.emacs.el "~/.emacs.el"))

        (save-excursion
          ;; remove any other initialisation file candidates
          (ignore-errors
            (f-move .emacs    (concat .emacs _data))
            (f-move .emacs.el (concat .emacs.el _data)))

          ;; Make init.el
          (org-babel-tangle)
          ; (byte-compile-file "~/.emacs.d/init.el")
          (load-file "~/.emacs.d/init.el")

          ;; Make README.org
          (org-babel-goto-named-src-block "make-readme")
          (org-babel-execute-src-block)

          ;; Acknowledgement
          (message "Tangled, compiled, and loaded init.el; and made README.md … %.06f seconds"
                   (float-time (time-since time)))))))

  (add-hook 'after-save-hook 'my/make-init-el-and-README nil 'local-to-this-file-please)
#+end_src

Where the following block has ~#+NAME: make-readme~ before it.
This source block generates the ~README~ for the associated Github repository.
#+name: make-readme
#+begin_src emacs-lisp :tangle no :export_never t
;; Update the table of contents in this file.
(toc-org-mode)
(toc-org-insert-toc)
(save-buffer)
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.org

     # Logos and birthday present painting
    ,#+HTML:" (s-collapse-whitespace (concat
    " <p align=\"center\">
       <img src=\"emacs-logo.png\" width=150 height=150/>
     </p>

     <p align=\"center\">
        <a href=\"https://www.gnu.org/software/emacs/\">
             <img src=\"https://img.shields.io/badge/GNU%20Emacs-" emacs-version "-b48ead.svg?style=plastic\"/></a>
        <a href=\"https://orgmode.org/\"><img src=\"https://img.shields.io/badge/org--mode-" org-version "-489a9f.svg?style=plastic\"/></a>
     </p>

     <p align=\"center\">
       <img src=\"emacs-birthday-present.png\" width=200 height=250/>
     </p>
    "))

   ;; My Literate Setup; need the empty new lines for the export
   "

     I enjoy reading others' /literate/ configuration files and
     incorporating what I learn into my own. The result is a
     sufficiently well-documented and accessible read that yields
     a stylish and functional system (•̀ᴗ•́)و

     This ~README.org~ has been automatically generated from my
     configuration and its contents below are accessible
     in (outdated) blog format, with /colour/, or as colourful
     PDF, [[https://alhassy.github.io/init/][here]]. Enjoy
     :smile:

     ,#+INCLUDE: init.org
    ")

    ;; No code execution on export
    ;; ⟪ For a particular block, we use “:eval never-export”. ⟫
    (let ((org-export-use-babel nil))
      (org-mode)
      (org-org-export-to-org)))
#+end_src
Alternatively, evaluate the above source block with ~C-c C-c~ to produce a ~README~
file.

Notes:
- Github supports several markup languages, one of which is Org-mode.
  - It seems that Github uses [[https://github.com/bdewey/org-ruby][org-ruby]] to convert org-mode to html.
  - [[https://github.com/novoid/github-orgmode-tests][Here]] is a repo demonstrating how Github interprets Org-mode files.
  - org-ruby supports inline ~#+HTML~ but [[https://github.com/wallyqs/org-ruby/issues/51][not html blocks]].

- It seems coloured HTML does not render well:
  #+begin_src emacs-lisp :tangle no
  (org-html-export-to-html)
  (shell-command "mv README.html README.md")
  #+end_src
- [[https://orgmode.org/manual/JavaScript-support.html][JavaScript supported display of web pages]] with:
  #+begin_src org :tangle no
  ,#+INFOJS_OPT: view:info toc:t buttons:t
  #+end_src
  This looks nice for standalone pages, but doesn't incorporate nicely with
  github README.org.

The above mentioned package ~toc-org~, which creates an up-to-date table
of contents in an org file, at any heading tagged ~:TOC:~.  It's useful
primarily for README files on Github.
#+begin_src emacs-lisp
(use-package toc-org
  ;; Automatically update toc when saving an Org file.
  :hook (org-mode . toc-org-mode))

;; Make toc-org links appear to be the same as their visible text.
(defun toc-org-hrefify-org (str &optional hash)
  "Given a heading, transform it into a href using the org-mode rules."
  (toc-org-format-visible-link str))
#+end_src

I'm not sure how I feel about actually having the Github-serving TOC in my
source file. It's nice to have around, from an essay-perspecive, but it breaks
HTML export since its links are /not/ well-behaved; e.g., ~:ignore:~-ed headlines
appear in the toc, but do not link to any visible heading in the HTML; likewise,
headings with URLS in their names break. As such, below I've developed a way to
erase it altogether ---alternatively, one could mark the toc as ~:noexport:~, but
this would then, in my current approach, not result in a toc in the resulting
README.
#+begin_src emacs-lisp
(cl-defun my/org-replace-tree-contents (heading &key (with "") (offset 0))
  "Replace the contents of org tree HEADING with WITH, starting at OFFSET.

Clear a subtree leaving first 3 lines untouched  ⇐  :offset 3
Deleting a tree & its contents                   ⇐  :offset -1, or any negative number.
Do nothing to a tree of 123456789 lines          ⇐  :offset 123456789

Precondition: offset < most-positive-fixnum; else we wrap to a negative number."
  (interactive)
  (save-excursion
    (beginning-of-buffer)
    (re-search-forward (format "^\\*+ %s" (regexp-quote heading)))
    ;; To avoid ‘forward-line’ from spilling onto other trees.
    (org-narrow-to-subtree)
    (org-mark-subtree)
    ;; The 1+ is to avoid the heading.
    (dotimes (_ (1+ offset)) (forward-line))
    (delete-region (region-beginning) (region-end))
    (insert with)
    (widen)))

;; Erase :TOC: body.
;; (my/org-replace-tree-contents "Table of Contents")
#+end_src
** Installing Emacs packages directly from source

[[https://github.com/quelpa/quelpa-use-package][Quelpa]] allows us to build Emacs packages directly from source repositories.  It
derives its name from the German word /Quelle/, for /souce/ [code], adjoined to
ELPA.  Its ~use-package~ interface allows us to use ~use-package~ like normal but
when we want to install a file from souce we use the keyword ~:quelpa t~.


#+begin_src emacs-lisp
(use-package quelpa-use-package)
#+end_src

Let's use this to obtain an improved info-mode from the EmacsWiki.
#+begin_src emacs-lisp
(use-package info+
  :quelpa (info+ :fetcher wiki :url "https://www.emacswiki.org/emacs/info%2b.el"))
#+end_src

** =magit= ---Emacs' porcelain interface to git
Let's setup an Emacs ‘porcelain’ interface to git ---it makes working with
version control tremendously convenient.  Moreover, I add a little pop-up so
that I don't forget to commit often!

Why use ~magit~ as the interface to the git version control system?  In ~magit~
buffer nearly everything can be acted upon: Press =return=, or =space=, to see
details and =tab= to see children items, usually.

First, let's setup our git credentials.
#+begin_src emacs-lisp
;; See here for a short & useful tutorial:
;; https://alvinalexander.com/git/git-show-change-username-email-address
(when (equal ""
(shell-command-to-string "git config user.name"))
  (shell-command "git config --global user.name \"Musa Al-hassy\"")
  (shell-command "git config --global user.email \"alhassy@gmail.com\""))
#+end_src

Below is my personal quick guide to working with magit ---for a full tutorial
see [[http://jr0cket.co.uk/2012/12/driving-git-with-emacs-pure-magic-with.html.html][jr0cket's blog]].

- ~dired~ :: See the contents of a particular directory.

- ~magit-init~ :: Put a project under version control.
     The mini-buffer will prompt you for the top level folder version.
     A ~.git~ folder will be created there.

- ~magit-status~ , ~C-x g~ :: See status in another buffer.
     Press ~?~ to see options, including:
  - g :: Refresh the status buffer.
  - TAB :: See collapsed items, such as what text has been changed.
  - ~q~ :: Quit magit, or go to previous magit screen.
  - ~s~ :: Stage, i.e., add, a file to version control.
       Add all untracked files by selecting the /Untracked files/ title.

       [[https://softwareengineering.stackexchange.com/a/119807/185815][The staging area is akin to a pet store; commiting is taking the pet home.]]

  - ~k~ :: Kill, i.e., delete a file locally.
  - ~K~ :: This' ~(magit-file-untrack)~ which does ~git rm --cached~.
  - ~i~ :: Add a file to the project ~.gitignore~ file. Nice stuff =)
  - ~u~ :: Unstage a specfif staged change highlighed by cursor.
       ~C-u s~ stages everything --tracked or not.
  - ~c~ :: Commit a change.
    - A new buffer for the commit message appears, you write it then
      commit with ~C-c C-c~ or otherwise cancel with ~C-c C-k~.
      These commands are mentioned to you in the minibuffer when you go to commit.
    - You can provide a commit to /each/ altered chunk of text!
      This is super neat, you make a series of local such commits rather
      than one nebulous global commit for the file. The ~magit~ interface
      makes this far more accessible than a standard terminal approach!
    - You can look at the unstaged changes, select a /region/, using ~C-SPC~ as usual,
      and commit only that if you want!
    - When looking over a commit, ~M-p/n~ to efficiently go to previous or next altered sections.
    - Amend a commit by pressing ~a~ on ~HEAD~.

  - ~d~ :: Show differences, another ~d~ or another option.
    - This is magit! Each hunk can be acted upon; e.g., ~s~ or ~c~ or ~k~ ;-)
  - ~v~ :: Revert a commit.
  - ~x~ :: Undo last commit. Tantamount to ~git reset HEAD~~ when cursor is on most recent
       commit; otherwise resets to whatever commit is under the cursor.
  - ~l~ :: Show the log, another ~l~ for current branch; other options will be displayed.
    - Here ~space~ shows details in another buffer while cursour remains in current
      buffer and, moreover, continuing to press ~space~ scrolls through the other buffer!
      Neato.
  - ~P~ :: Push.
  - ~F~ :: Pull.
  - ~:~ :: Execute a raw git command; e.g., enter ~whatchanged~.

Notice that every time you press one of these commands, a ‘pop-up’ of realted
git options appears! Thus not only is there no need to memorise many of them,
but this approach makes /discovering/ other commands easier.

Below are the git repos I'd like to clone ---along with a function to do so
quickly.
#+begin_src emacs-lisp
(use-package magit)

;; Do not ask about this variable when cloning.
(setq magit-clone-set-remote.pushDefault t)

(cl-defun maybe-clone (remote &optional (local (concat "~/" (file-name-base remote))))
  "Clone a REMOTE repository if the LOCAL directory does not exist.

Yields ‘repo-already-exists’ when no cloning transpires,
otherwise yields ‘cloned-repo’.

LOCAL is optional and defaults to the base name; e.g.,
if REMOTE is https://github.com/X/Y then LOCAL becomes ~/Y."
  (if (file-directory-p local)
      'repo-already-exists
    (async-shell-command (concat "git clone " remote " " local))
    (add-to-list 'magit-repository-directories `(,local   . 0))
    'cloned-repo))

(maybe-clone "https://github.com/alhassy/emacs.d" "~/.emacs.d")
(maybe-clone "https://github.com/alhassy/alhassy.github.io")
(maybe-clone "https://github.com/alhassy/CheatSheet")
(maybe-clone "https://github.com/alhassy/ElispCheatSheet")
(maybe-clone "https://github.com/alhassy/CatsCheatSheet")
(maybe-clone "https://github.com/alhassy/islam")

;; For brevity, many more ‘maybe-clone’ clauses are hidden in the source file.
#+end_src
Let's always notify ourselves of a file that has [[https://tpapp.github.io/post/check-uncommitted/][uncommited changes]]
---we might have had to step away from the computer and forgotten to commit.
#+begin_src emacs-lisp
(require 'magit-git)

(defun my/magit-check-file-and-popup ()
  "If the file is version controlled with git
  and has uncommitted changes, open the magit status popup."
  (let ((file (buffer-file-name)))
    (when (and file (magit-anything-modified-p t file))
      (message "This file has uncommited changes!")
      (when nil ;; Became annyoying after some time.
      (split-window-below)
      (other-window 1)
      (magit-status)))))

;; I usually have local variables, so I want the message to show
;; after the locals have been loaded.
(add-hook 'find-file-hook
  '(lambda ()
      (add-hook 'hack-local-variables-hook 'my/magit-check-file-and-popup)))
#+end_src

Finally, one of the main points for using version control is to have access to
historic versions of a file. The following utility allows us to ~M-x
git-timemachine~ on a file and use ~p/n/g/q~ to look at previous, next, goto
arbitrary historic versions, or quit.
- If we want to roll back to a previous version, we just ~write-file~ or ~C-x C-s~
  as usual! The power of text!
#+begin_src emacs-lisp
(use-package git-timemachine)
#+end_src

** Syncing to the System's =$PATH=
For one reason or another, on OS X it seems that an Emacs instance
begun from the terminal may not inherit the terminal's environment
variables, thus making it difficult to use utilities like ~pdflatex~
when Org-mode attempts to produce a PDF.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :init
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize)))
#+end_src

See the [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] documentation for setting other environment variables.
** Keeping my system up to date
Let's ensure our system is always up to date.
#+begin_src emacs-lisp
(defun my/stay-up-to-date ()
  "Ensure that OS and Emacs package listings are up to date.

   Takes ~5 seconds when everything is up to date."
  (async-shell-command "brew update && brew upgrade")
  (other-window 1)
  (rename-buffer "Keeping-system-up-to-date")

  (package-refresh-contents 'please-do-so-in-the-background)
  (message "Updated Emacs package manager.")
  (other-window 1))

(add-hook 'after-init-hook 'my/stay-up-to-date)

;; For now, doing this since I'm also calling my/stay-up-to-date with
;; after-init-hook which hides the startup message.
(add-hook 'after-init-hook 'display-startup-echo-area-message)
#+end_src

** Installing OS packages from within Emacs ---Amethyst!

Sometimes Emacs packages depend on existing system binaries, ~use-package~ let's
us ensure these exist using the ~:ensure-system-package~ keyword extension.

- This is like ~:ensure t~ but operates at the OS level and uses your default
  OS package manager.

Let's obtain the extension.
#+begin_src emacs-lisp
;; Auto installing OS system packages
(use-package use-package-ensure-system-package)
#+end_src
Here's an example use:
#+begin_src emacs-lisp :tangle no
(shell-command-to-string "type rg") ;; ⇒ rg not found
(use-package rg
  :ensure-system-package rg) ;; ⇒ There's a buffer *system-packages*
                             ;;   installing this tool at the OS level!
#+end_src
If you look at the ~*Messages*~ buffer, via ~C-h e~, on my machine it says
~brew install rg: finished~ ---it uses ~brew~ which is my OS package manager!

- The [[https://github.com/jwiegley/use-package#use-package-ensure-system-package][use-package-ensure-system-package]] documentation for a flurry of use cases.

The extension makes use of [[https://gitlab.com/jabranham/system-packages][system-packages]]; see its documentation to learn
more about managing installed OS packages from within Emacs. This is itself
a powerful tool, however it's interface ~M-x system-packages-install~ leaves much
to be desired ---namely, tab-compleition listing all available packages,
seeing their descriptions, and visiting their webpages.
This is remedied by [[https://github.com/emacs-helm/helm-system-packages][M-x helm-system-packages]] then ~RET~ to see a system
package's description, or ~TAB~ for the other features!
/This is so cool!/

#+begin_src emacs-lisp
;; An Emacs-based interface to the package manager of your operating system.
(use-package helm-system-packages)
#+end_src

The Helm counterpart is great for /discovarability/, whereas
the plain ~system-packages~ is great for /programmability/.

It is tedious to arrange my program windows manually, and as such I love tiling
window managers, which automatically arrange them.  I had been using [[https://xmonad.org][xmonad]]
until recently when I obtained a Mac machine and now use [[https://ianyh.com/amethyst/][Amethyst]] ---“Tiling
window manager for macOS along the lines of xmonad.”

#+begin_src emacs-lisp
;; Unlike the Helm variant, we need to specify our OS pacman.
(setq system-packages-package-manager 'brew)

;; Use “brew cask install” instead of “brew install” for installing programs.
(setf (nth 2 (assoc 'brew system-packages-supported-package-managers))
      '(install . "brew cask install"))

;; If the given system package doesn't exist; install it.
;; (system-packages-ensure "amethyst")
#+end_src

Neato! Now I can live in Emacs even more ^_^

** Who am I? ---Using Gnus for Gmail
Let's set the following personal Emacs-wide variables ---to be used in other
locations besides email.
#+begin_src emacs-lisp
(setq user-full-name    "Musa Al-hassy"
      user-mail-address "alhassy@gmail.com")
#+end_src

By default, in Emacs, we may send mail: Write it in Emacs with ~C-x m~,
then press ~C-c C-c~ to have it sent via your OS's default mailing system
---mine appears to be Gmail via the browser. Or cancel sending mail with
~C-c C-k~ ---the same commands for org-capturing, discussed below (•̀ᴗ•́)و

To send and read email in Emacs we use [[https://en.wikipedia.org/wiki/Gnus][GNUS]], which, like GNU itself, is a
recursive acronym: GNUS Network User Service.

1. Execute, rather place in your init:
   #+begin_src emacs-lisp
        (setq message-send-mail-function 'smtpmail-send-it)
   #+end_src
   Revert to the default OS mailing method by setting this variable to
   ~mailclient-send-it~.

2. Follow only the [[https://www.emacswiki.org/emacs/GnusGmail#toc1][quickstart here]]; namely, make a file named ~~/.gnus~ containing:
   #+begin_src emacs-lisp :tangle ~/.gnus
        ;; user-full-name and user-mail-address should be defined

   (setq gnus-select-method
         '(nnimap "gmail"
                  (nnimap-address "imap.gmail.com")
                  (nnimap-server-port "imaps")
                  (nnimap-stream ssl)))

   (setq smtpmail-smtp-server "smtp.gmail.com"
         smtpmail-smtp-service 587
         gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")
   #+end_src

3. Enable “2 step authentication” for Gmail following [[https://emacs.stackexchange.com/a/33309/10352][these]] instructions.

4. You will then obtain a secret password, the ~x~ marks below, which you insert
   in a file named ~~/.authinfo~ as follows ---using your email address.
   #+begin_src shell :tangle no
        machine imap.gmail.com login alhassy@gmail.com password xxxxxxxxxxxxxxxx port imaps
        machine smtp.gmail.com login alhassy@gmail.com password xxxxxxxxxxxxxxxx port 587
   #+end_src

5. In Emacs, ~M-x gnus~ to see what's there.

   Or compose mail with ~C-x m~ then send it with ~C-c C-c~.
   - Press ~C-h m~ to learn more about message mode for mail composition; or
     read the [[https://www.gnus.org/manual/message.pdf][Message Manual]].

In gnus, by default items you've looked at disappear ---i.e., are archived.
They can still be viewed in, say, your online browser if you like.
In the ~Group~ view, ~R~ resets gnus, possibly retriving mail or alterations
from other mail clients. ~q~ exits gnus in ~Group~ mode, ~q~ exits the particular
view to go back to summary mode. Only after pressing ~q~ from within a group
do changes take effect on articles ---such as moves, reads, deletes, etc.

- RET :: Open an article.

- B m :: Move an article, in its current state, to another group ---i.e.,
     ‘label’ using Gmail parlance.

     Something to consider doing when finished with an article.

     To delete an article, simply move it to ‘trash’ ---of course this will delete it
     in other mail clients as well. There is no return from trash.

     Emails can always be archieved ---never delete, maybe?

- ! :: Mark an article as read, but to be kept around ---e.g., you have not
     replied to it, or it requires more reading at a later time.

- R :: Reply to email with sender's content there in place.
  - ~r~ to reply to an email with sender's content in adjacent buffer.

- d :: Mark an article as done, i.e., read it and it can be archived.

Learn more by reading [[https://www.gnus.org/manual.html][The Gnus Manual]]; also available within Emacs by ~C-h i m
gnus~ (•̀ᴗ•́)و
- Or look at the [[https://www.gnu.org/software/emacs/refcards/pdf/gnus-refcard.pdf][Gnus Reference Card]].
- Or, less comprehensively, this [[https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org#subscribe-groups][outline]].
** Hydra: Supply a prefix only once
Sometimes we have keybindings that share a common prefix, say ~C-c j~ and ~C-c k~,
and we invoke them in an arbitrary sequence, it would be nice to invoke the
shared prefix /only once/ thereby having:
| ~C-c j C-c j C-c k C-c k M-3 C-c j M-5 C-c k~ | ≈ | ~C-c jjkk3j5k~ |

- The [[https://github.com/abo-abo/hydra#the-one-with-the-least-amount-of-code][“hydra-zoom”]] example from the documentation really showcases this utility.
- After the prefix is supplied, all extensions are shown in a minibuffer.

#+begin_src emacs-lisp
;; Invoke all possible key extensions having a common prefix by
;; supplying the prefix only once.
(use-package hydra)

;; The standard syntax:
;; (defhydra hydra-example (global-map "C-c v") ;; Prefix
;;   ;; List of triples (extension method description) )
#+end_src

From the [[https://github.com/abo-abo/hydra][Hydra]] repository is a ‘description for poets’:
#+begin_quote
Once you summon the Hydra through the prefixed binding (the body + any one
head), all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
original purpose, calling his proper command. This makes the Hydra very
seamless, it's like a minor mode that disables itself auto-magically.
#+end_quote

See [[Taking a tour of one's edits]] below for a small and useful example.

* Conclusion
Emacs   is   fun ^_^

Bye!
